#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <iostream>
#include <array> 

#include "window.h"
#include "shader.h"
#include "vertex.h"
#include "vertex_buffer.h"
#include "index_buffer.h"

static void processInput(Window* window);

// Window size
constexpr int WIDTH = 720;
constexpr int HEIGHT = 720;
constexpr const char* TITLE = "simple 2D game";

glm::vec3 translation = glm::vec3(0, 0, 0);
constexpr float speedMovement = 0.0025;


int main()
{
  Window window{ WIDTH, HEIGHT, TITLE };

  // glew: initialize
  // ---------------------------------------
  glewInit();

  // build and compile our shader program
  // ------------------------------------
  Shader shader { "../shaders/vertex.shader", "../shaders/fragment.shader" };

  // 3D Cube  
  // Vertex vertices[] = {
  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f, -0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f,  0.5f, -0.5f ),   glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( 0.5f,  0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( -0.5f,  0.5f, -0.5f ),  glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 0, 1, 0 ) },

  //   Vertex { glm::vec3( -0.5f, -0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f, -0.5f,  0.5f ),   glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( -0.5f,  0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f,  0.5f ),  glm::vec3( 0, 1, 0 ) },

  //   Vertex { glm::vec3( -0.5f,  0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( -0.5f,  0.5f, -0.5f ),  glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( -0.5f,  0.5f,  0.5f ),  glm::vec3( 0, 1, 0 ) },

  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f,  0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f, -0.5f, -0.5f ),   glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( 0.5f, -0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( 0.5f, -0.5f,  0.5f ),   glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 0, 1, 0 ) }, 

  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f, -0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f, -0.5f,  0.5f ),   glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( 0.5f, -0.5f,  0.5f ),   glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( -0.5f, -0.5f, -0.5f ),  glm::vec3( 0, 1, 0 ) },

  //   Vertex { glm::vec3( -0.5f,  0.5f, -0.5f ),  glm::vec3( 1, 0, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f,  0.5f, -0.5f ),   glm::vec3( 0, 1, 0 ) }, 
  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 0, 0, 1 ) },
  //   Vertex { glm::vec3( 0.5f,  0.5f,  0.5f ),   glm::vec3( 0, 1, 0 ) },
  //   Vertex { glm::vec3( -0.5f,  0.5f,  0.5f ),  glm::vec3( 1, 0, 0 ) },
  //   Vertex { glm::vec3( -0.5f,  0.5f, -0.5f ),  glm::vec3( 0, 1, 0 ) },  
  // };

  // square
  const std::array<Vertex, 4> vertices = {
    Vertex { glm::vec3(-0.5, +0.5, 0), glm::vec3(1, 0, 0) },
    Vertex { glm::vec3(+0.5, +0.5, 0), glm::vec3(0, 1, 0) },
    Vertex { glm::vec3(-0.5, -0.5, 0), glm::vec3(0, 0, 1) },
    Vertex { glm::vec3(+0.5, -0.5, 0), glm::vec3(1, 0, 1) }
  };
  const std::array<uint32_t, 6> indices = { 0,2,3,  0,1,3 };

  uint32_t vertexArray;
  glGenVertexArrays(1, &vertexArray);
  glBindVertexArray(vertexArray);

  VertexBuffer vertexBuffer { vertices.size()*sizeof(Vertex), vertices.data(), GL_DYNAMIC_DRAW };
  IndexBuffer indexBuffer { indices.size()*sizeof(uint32_t), indices.data(), GL_DYNAMIC_DRAW };
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*) 0);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*) (sizeof(Vertex::position)));
  glEnableVertexAttribArray(1);
  

  // render loop
  // -----------
  while (!window.shouldClose())
  {
    //const float deltaTime = static_cast<float>(glfwGetTime());

    // input
    // ------
    processInput(&window);
    
    // render
    // ------
    window.clear();
    shader.use();
    glBindVertexArray(vertexArray);

    // Model: maps from an object's local coordinate space into world space
    glm::mat4 model = glm::mat4(1.0f);
    model = glm::translate(model, glm::vec3(0, 0, 0));
    shader.setMatrix4Float("model", model);
    
    // View: from world space to camera space
    glm::mat4 view = glm::mat4(1.0f);
    view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3));
    shader.setMatrix4Float("view", view);
    
    // Projection: from camera to screen.
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), static_cast<float>(WIDTH/HEIGHT), 0.1f, 100.f);
    shader.setMatrix4Float("projection", projection);

    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    //glDrawArrays(GL_TRIANGLES, 0, numVertices);
    
    window.swapBuffersAndPullEvents();
  }

  window.terminate();

  return 0;
}

void processInput(Window* window)
{
  if(window->getKey(GLFW_KEY_ESCAPE) == GLFW_PRESS)
    window->close();

  // left
  if(window->getKey(GLFW_KEY_A) == GLFW_PRESS)
    translation += glm::vec3(-1, 0, 0) * speedMovement;
  // right
  if(window->getKey(GLFW_KEY_D) == GLFW_PRESS)
    translation += glm::vec3(1, 0, 0) * speedMovement;
  // up
  if(window->getKey(GLFW_KEY_W) == GLFW_PRESS)
    translation += glm::vec3(0, 1, 0) * speedMovement;
  // down
  if(window->getKey(GLFW_KEY_S) == GLFW_PRESS)
    translation += glm::vec3(0, -1, 0) * speedMovement;

}